Boot time & Memory usage optimization
1. Linux Kernel Boot Time Optimization
A Linux boot sequence has three main stages:
(a) Bootloader time â†’ (b) Kernel boot time â†’ (c) User-space init
Weâ€™ll focus on bootloader and kernel.

1.1 Optimize Bootloader Time
Common bootloaders: U-Boot, GRUB, Barebox.
Strategies:
    â€¢ Disable delays: Many bootloaders wait for user input (e.g., 3â€“5 sec timeout). Set timeout to	 0 or 1.
    â€¢ Skip unnecessary hardware init: If the bootloader initializes hardware not needed for your boot path (USB, extra network cards), disable that in bootloader config.
    â€¢ Use prebuilt boot script: Instead of interactive shell, load kernel + DTB + initramfs directly.
    â€¢ Use smaller bootloader: If you donâ€™t need networking or USB in bootloader stage, compile a minimal build.
Example (U-Boot config):
setenv bootdelay 0
saveenv
And in U-Boot .config:
    â€¢ Disable features like CONFIG_CMD_NET, CONFIG_CMD_USB if unused.
1.2 Optimize Kernel Boot Time
Techniques:
    1. Build a minimal kernel
        â—¦ Remove drivers/subsystems not used at boot (especially loadable modules not required early).
        â—¦ Example: disable CONFIG_DEBUG_* if not debugging.
    2. Use initramfs efficiently
        â—¦ Only include required binaries, scripts, and drivers.
        â—¦ Compress with lz4 or zstd for faster decompression.
    3. Parallel driver init
        â—¦ CONFIG_BOOT_PRINTK_DELAY and initcall debugging can show slow drivers.
        â—¦ Use initcall_debug boot parameter to measure driver init times.
    4. Defer driver probing
        â—¦ Mark non-critical device drivers as deferred so kernel continues booting without waiting.
    5. Profile boot with tools:
        â—¦ bootchart or systemd-analyze plot (if using systemd).
        â—¦ dmesg timestamps (dmesg -T) to identify slow init functions.
Example boot param: initcall_debug loglevel=7 printk.time=1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ðŸ”Ž 1. Understand Boot Time
In Linux (including Ubuntu), boot has three phases:
    1. Bootloader (GRUB / EFI) â€“ initializes and loads kernel.
    2. Kernel initialization â€“ hardware detection, drivers, mounting rootfs.
    3. User-space init (systemd) â€“ services and daemons start.
ðŸ‘‰ To analyze where time is spent:
systemd-analyze
systemd-analyze blame
systemd-analyze critical-chain
    â€¢ systemd-analyze â†’ shows total boot time split between kernel & userspace.
    â€¢ blame â†’ lists services by startup time.
    â€¢ critical-chain â†’ shows dependency path of slow services.
âš¡ 2. Optimize Bootloader (GRUB)
Edit /etc/default/grub:
    â€¢ Reduce timeout: GRUB_TIMEOUT=0
    â€¢ Disable recovery & extra console messages: GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
    â€¢ Then run: sudo update-grub
âš¡ 3. Optimize Kernel Boot
Inside VirtualBox, many drivers arenâ€™t needed:
    â€¢ Blacklist unused kernel modules:
Edit /etc/modprobe.d/blacklist.conf and add modules not required (like Wi-Fi, Bluetooth if VM doesnâ€™t use them). .................................lsmod with this help
 Add entries like:
blacklist bluetooth
blacklist btusb
blacklist btrtl
blacklist iwlwifi
blacklist uvcvideo
Regenerate initramfs so blacklist applies at boot: sudo update-initramfs -u
âš¡ 4 .Create a Smaller Initramfs
The initramfs is the temporary root filesystem loaded by the kernel before your real rootfs. By default, Ubuntu includes many modules for all hardware types â†’ slows down boot. You can generate a minimal initramfs containing only what your VM needs.
Steps:
    1. Edit initramfs config: sudo nano /etc/initramfs-tools/initramfs.conf
       Change: MODULES=most                              To: MODULES=dep
       â†’ most = include almost all drivers,
â†’ dep = only include drivers required for your systemâ€™s current hardware.
    2. Rebuild initramfs: sudo update-initramfs -u -k all
    3. Reboot and test boot speed: systemd-analyze
NOW, REBBOT AND CHECK CHANGES 

	











2. Optimization of Memory Usage in the Linux Kernel
2.1 Understanding Kernel Memory Segments
When the kernel boots, memory is divided into:
    â€¢ Text segment: Kernel code.
    â€¢ Data segment: Initialized globals.
    â€¢ BSS: Zero-initialized globals.
    â€¢ Heap: Dynamic allocations (slab, buddy allocator).
    â€¢ Page cache: For file I/O.
    â€¢ vmalloc area: Non-contiguous allocations.
You can check these with:
cat /proc/meminfo
cat /proc/iomem
cat /proc/slabinfo
2.2 Key Tools
/proc/meminfo â€“ shows system-wide memory usage
Example fields:
    â€¢ MemTotal, MemFree: Overall memory stats.
    â€¢ Buffers / Cached: Page cache usage.
    â€¢ Slab, SReclaimable, SUnreclaim: Kernel object cache usage.
    â€¢ VmallocTotal / VmallocUsed: vmalloc area usage.
/proc/iomem â€“ shows memory map (reserved for kernel, devices, etc.)
/proc/slabinfo â€“ shows slab allocator caches, useful to detect driver memory leaks.

2.3 Memory Optimization Techniques
    â€¢ Reduce kernel size: Disable unused features in .config.
    â€¢ Minimize slab usage: Free allocated objects when not needed.
    â€¢ Use CONFIG_SLUB_DEBUG during dev to catch leaks.
    â€¢ Drop unused firmware: Remove unused .bin files from /lib/firmware.
    â€¢ Use zswap or zram if RAM is very limited.
    â€¢ Reduce vmalloc pressure: Use kmalloc instead of vmalloc if physically contiguous memory is acceptable.

3. Device-Driver-Specific Boot & Memory Optimization
When writing Linux device drivers, you can help the system boot and run faster:
Boot Time:
    â€¢ Mark driver as __init if only needed at boot â€” memory is freed after init.
    â€¢ Use late_initcall() if your driver is not critical to early boot.
    â€¢ Avoid long msleep() or udelay() in probe.
Memory Usage:
    â€¢ Use devm_kmalloc() to auto-free on driver detach.
    â€¢ Release I/O regions (release_mem_region) if reserved but unused.
    â€¢ Use smaller buffers â€” donâ€™t over-allocate "just in case".
    â€¢ Test with kmemleak (kernel tool) to detect leaks in driver code.

